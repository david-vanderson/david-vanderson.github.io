<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <link type="text/css" rel="stylesheet" href="/style.css">
    <link type="text/css" rel="stylesheet" href="/highlight.css">
    
  <style>
    .feed {
      margin-top: 2em;
    }

    .feed>div {
      margin: 0 -20px;
      padding: 5px 20px;
      margin-bottom: 1em;
    }

    .feed>div>h2 {
      margin-top: 0.4em;
    }

    .feed>div[id]:target {
      animation: pulse-div 2s ease-in-out 1 forwards;
    }

    @keyframes pulse-div {

      0%,
      100% {
        background-color: #222;
      }

      50% {
        background-color: #111;
      }
    }
  </style>

  </head>
  <body id="body">
    <nav>
      <a href="/">Home</a>
       &nbsp; • &nbsp;
      <a href="/demo/">Demo</a>
       &nbsp; • &nbsp;
      <a href="/docs/">Docs</a>
       &nbsp; • &nbsp;
      <a href="/community/">Community</a>
      
         &nbsp; • &nbsp;
        <a href="/log/2025/">Devlog</a>
      
       &nbsp; • &nbsp;
      <a href="https://github.com/david-vanderson/dvui">Code</a>
    </nav>
    <h1 class="site-title"><img src="/dvui.png" height="120"></h1>
    <h1 class="site-subtitle"></h1>
    
  <h1 class="title">DVUI Devlog 2025</h1>
  <div><div id="about"><p><a href="/log/index.xml">RSS Feed</a></p><p><a href="/log/">Archive</a></p></div></div>
  <div class="feed">
    <div id="2025-11-01">
      <span>November 01, 2025</span>
      <h2><a href="#2025-11-01">October 2025
</a></h2>
      <p><strong>5</strong> people contributed this month with <strong>146</strong> commits.</p><h4>Screen Reader Support</h4><p>Huge thanks to <strong>Paul Hatchman</strong> who implemented OS <strong>screen-reader</strong> support!</p><p>DVUI now integrates with <a href="https://accesskit.dev/" target="_blank">AccessKit</a> via their <a href="https://github.com/AccessKit/accesskit-c" target="_blank">C API</a> to communicate the dvui widget tree to the OS-specific accessibility apis.</p><ul><li>use <code>-Daccesskit=static</code> or <code>-Daccesskit=shared</code> (also <code>-fsys=accesskit</code>)</li><li>supports Windows, Mac, and Linux</li><li>can get accessibility input events (like focus or activate)</li><li>see <a href="https://github.com/david-vanderson/dvui/blob/main/readme-accessibility.md" target="_blank">readme-accessibility</a> for details</li><li>please file bugs and missing features so we can continue to improve this</li></ul><p>This is a huge step for accessibility - horay!</p><h4>Focus Groups</h4><p>As part of the accessibility work, we found that dvui was not handling keyboard navigation correctly for logical groups of widgets (radio groups, tabs, menus, trees, grids).</p><p>Now TAB will move focus to the group, arrow keys move focus inside a group, and a second TAB will move past the group.</p><p>This is done automatically for tabs/menus/trees/grids, and available as <code>radioGroup</code> for radio buttons and <code>focusGroup</code> for arbitrary groups.</p><h4>Other Improvements:</h4><ul><li>Backend logging integrated with zig logging (<strong>Teodor Källman</strong>)</li><li>TextLayoutWidget handles invalid utf8 when <code>.cache_layout</code> (<strong>Teodor Källman</strong>)</li><li>LabelWidget - will ellipsize when not enough room</li><li>Debug - new “Frame Times” graph can help understand if jitter is coming from between Window.begin/end</li><li>new <code>link()</code> that renders URLs and handles clicks (also TextLayoutWidget.addLink)</li><li>Theme.max_default_corner_radius - easier to have themes with sharper corners</li></ul><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-10-02">
      <span>October 02, 2025</span>
      <h2><a href="#2025-10-02">Septemer 2025
</a></h2>
      <p><strong>6</strong> people contributed this month with <strong>145</strong> commits.</p><h4>Struct UI</h4><p>Big thanks to <strong>Paul Hatchman</strong> who overhauled <code>dvui.structUI</code> and it’s no longer experimental.</p><ul><li>automatically generates a UI to edit arbitrary zig structs</li><li>makes it very easy to quickly edit arbitrary data, especially in a debug window</li><li>see the demo “Struct UI” for examples</li></ul><h4>TextLayout/TextEntry Performance</h4><p>A lot of work went into improving the speed of text layout and editing:</p><ul><li>kerning options added (can turn off to improve speed)</li><li>ascii fast path for glyph measurement lookup</li></ul><p>The big enhancment is adding <a href="#2025-09-24">partial rendering</a>:</p><ul><li>new <code>.cache_layout</code> option</li><li>textLayout only processes visible text</li><li>textEntry communicates with textLayout to process only visible text while editing</li><li>performance is now independent of the size of the document</li><li>see demo “Large Doc” button in both “Text Entry” and “Text Layout” sections</li></ul><h4>Theme Cleanup:</h4><p>We did another round of theme work including:</p><ul><li>Options: add back hover/press colors<ul><li>these were useful and expected</li></ul></li><li>Options: add <code>*Theme</code><ul><li>allows passing a separate theme instead of setting/resetting the global theme</li><li>demo “Styling” shows a button for each builtin theme</li></ul></li><li>Theme: add styles app1/app2/app3<ul><li>reserved for application use (dvui won’t use for builtin widgets)</li><li>place for applications to put colors that cooperate with the dvui theming system</li></ul></li></ul><h4>Other Improvements:</h4><ul><li>JPGEncoder - can write JPG via stb_image_write (<strong>Teodor Källman</strong>)</li><li>TreeWidget - animations and tracking state (<strong>Colton Franklin</strong>)</li><li><code>clickedEx()</code> - can check for alternate mouse buttons (<strong>rasp2006</strong>)</li><li>better appearance at scales between 100-200% (like Windows 125%)</li><li>stroking a path with very acute angles more accurately preserves stroke thickness</li></ul><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-09-24">
      <span>September 24, 2025</span>
      <h2><a href="#2025-09-24">Large Document Speed
</a></h2>
      <p>We now have fast partial rendering of large text documents in <code>TextLayoutWidget</code> and <code>TextEntryWidget</code>.</p><ul><li>Load the demo</li><li>Go to the “Text Entry” or “Text Layout” sections</li><li>Click the “Large Doc” button at top right</li><li>Scrolling/Selection/Editing are fast independent of the amount of text</li></ul><p>The neat thing is the api for feeding text into these widgets is unchanged (thanks <strong>Teodor Källman</strong>!).</p><p>It works generally the way you might expect:</p><ul><li>textLayout records the height after each newline (at least 200px apart)</li><li>when passed <code>.cache_layout = true</code>, it uses the heights from last frame to only render the visible text</li></ul><p>For textEntry editing, it combines the byte range affected by the edits with the visible text.</p><p>Things that require passing <code>.cache_layout = false</code> for a frame:</p><ul><li>changing the text content outside of textEntry</li><li>changing the font</li><li>changing the font line spacing</li></ul><p>textLayout detects a few situations automatically:</p><ul><li>natural scale of app changes</li><li>break_lines changes</li><li>width changes when break_lines is true</li></ul><p>dvui is starting to be reasonable for file editing!</p><p>If you have any questions or problems, please ask on Discord or file an issue/discussion on Github.  Thanks!</p>
    </div>
  
    <div id="2025-09-05">
      <span>September 05, 2025</span>
      <h2><a href="#2025-09-05">Cross Widget Dragging
</a></h2>
      <p>With huge help from <strong>Colton Franklin</strong> we now have the pieces in place to support drag-n-drop across widgets.</p><p>Here are the questions for drag-n-drop:</p><ul><li>How does the drag start?</li><li>What is being dragged?</li><li>Who draws the thing being dragged?</li><li>How do you know when a drag is happening?</li><li>How does the drag end?</li></ul><p>For dragging inside a single widget, the answers are pretty easy:</p><ul><li><p>Capture the mouse on mouse down</p><ul><li>call <code>dvui.dragPreStart()</code></li></ul></li><li><p>Drag starts once mouse motion exceeds the drag threshold (<code>dvui.dragging()</code> is non-null)</p><ul><li>the single widget records what is being dragged</li></ul></li><li><p>Drag is happening while we have capture and <code>dvui.dragging()</code> is non-null</p><ul><li>the single widget draws an icon (in a FloatingWidget) to depict the thing being dragged</li></ul></li><li><p>Finish the drag on mouse up</p><ul><li>because we have capture, we always see the mouse up</li><li>end the drag <code>dvui.dragEnd()</code></li><li>give up mouse capture</li></ul></li></ul><h4>Drag-n-Drop Across Widgets:</h4><p>We added a “drag name” mechanism.  You assign a well-known string for each logical kind of cross-widget drag. All the widgets involved use that drag name to coordinate.</p><p>The sequence for cross-widget dragging:</p><ul><li><p>Starting widget (still) captures the mouse on mouse down</p><ul><li>pass the drag name to <code>dvui.dragPreStart()</code></li></ul></li><li><p>Drag starts once mouse motion exceeds the drag threshold (<code>dvui.dragging()</code> is non-null)</p><ul><li>starting widget must give up mouse capture</li><li>application must record what is being dragged</li></ul></li><li><p>Drag is happening while <code>dvui.dragName()</code> is true</p><ul><li>widgets use this to show “I’m a valid drop target”</li><li>one widget (usually the starting widget) or separate code draws (in a FloatingWidget with <code>.mouse_events = false</code>) the thing being dragged</li><li>drag icon position is <code>dvui.currentWindow().mouse_pt.plus(dvui.dragOffset())</code></li></ul></li><li><p>Widgets must pass the drag name to <code>dvui.eventMatch()</code> to match mouse events</p></li><li><p>Finish the drag on mouse up</p><ul><li>if a participating widget gets mouse up, it is a successful drop</li><li>end the drag <code>dvui.dragEnd()</code></li></ul></li><li><p>Unhandled mouse up cancels</p><ul><li>if no widget handles mouse up, <code>dvui.Window</code> will see it and cancel the drag</li></ul></li></ul><p>This is enough pieces to implement cross-widget drag-n-drop, including multiple separate non-interacting cross-widget drags.</p><p>In the demo “Reorder / Tree” section, expand the “Advanced” section and toggle the checkbox.  This shows how you can drag things from the simple reorder section to the advanced section.</p><p>If you have any questions or problems, please ask on Discord or file an issue/discussion on Github!</p>
    </div>
  
    <div id="2025-09-02">
      <span>September 02, 2025</span>
      <h2><a href="#2025-09-02">August 2025
</a></h2>
      <p><strong>6</strong> people contributed this month with <strong>111</strong> commits.</p><h4>Zig 0.15.1:</h4><p>We just (start of September) updated to Zig 0.15.1.  Mostly went smoothly with a few exceptions:</p><ul><li><del>dx11 backend is waiting on a dependency update</del> (fixed)</li><li><del>we need to use the llvm backend due to hitting some bug in the native x86_64 backend</del> (fixed)</li></ul><h4>Theme Cleanup:</h4><p>We took the first big step to cleaning up how themes work.  Even just with colors, it’s tricky:</p><ul><li>a theme can’t have separate colors for each widget<ul><li>no room for colors for 3rd party widgets</li><li>very hard for theme authors</li></ul></li></ul><p>So we are trying to move towards having a theme with just enough “intention-based” colors, like:</p><ul><li>a few colors for things you press (like buttons)</li><li>a few for things that have text content (like textLayout)</li><li>a few for containers of other widgets (like windows)</li></ul><p>This is combined with a fallback system, so (for example) if the theme provides a button fill color, but no button hover fill color, dvui will create one by lightening/darkening the fill color (depending on the light/dark setting of the theme).</p><p>I think we are headed in the right direction, but will likely need a few more tweaks, possibly including:</p><ul><li>colors in the theme reserved for application use</li><li>color palette for stuff like different lines in a plot</li></ul><p>Theme stuff dovetails into how to override colors for single widgets.  We aren’t as far along here, but investigating a tiered approach:</p><ul><li>easy way to override a few colors (text, fill, border)<ul><li>typically stuff that is used in an ad-hoc way, maybe just during development</li></ul></li><li>general way to override all colors<ul><li>might involve copying/modifying the theme locally</li></ul></li><li>still figuring out how to flow overrides from parent to child widgets</li></ul><p>Thanks very much to <strong>Teodor Källman</strong> for working through this!</p><h4>Menus:</h4><p>Big thanks to <strong>BrotherJ</strong> for carefully detailing ways in which dvui menu behavior did not match normal expectations.</p><p>We fixed a lot of corner cases, so they should feel more like typical OS menus.</p><h4>Cross Widget Dragging:</h4><p>We now have a serious answer for how to do <a href="#2025-09-05">cross-widget dragging</a>.</p><p>Thank you to <strong>Colton Franklin</strong> for working through this!</p><h4>Other Improvements:</h4><ul><li>Paned got autofit for the first child</li><li>zls workarounds to get correct backend suggestions</li><li>added max fps slider to debug window for easy testing</li><li>button order setting that affects <code>dvui.dialog()</code><ul><li>default on Windows is “Ok” then “Cancel”</li><li>otherwise “Cancel” is before “Ok”</li></ul></li></ul><p>Thank you very much to everyone who landed at least one commit:</p><ul><li>Teodor Källman</li><li>BrotherJ</li><li>Paul Hatchman</li><li>Colton Franklin</li><li>thuvasooriya</li></ul><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-08-01">
      <span>August 01, 2025</span>
      <h2><a href="#2025-08-01">July 2025
</a></h2>
      <p><strong>7</strong> people contributed this month with <strong>229</strong> commits.</p><p><strong>Teodor Källman</strong> kept the streak alive:</p><ul><li>new theme editor example in the demo</li><li>online options editor<ul><li>override widget Options live to see the changes</li><li>open the dvui debug window</li><li>select a widget (using Debug Under Mouse)</li><li>click “Edit Options” in top right corner</li></ul></li></ul><p>In general this month had tons of improvements across the board:</p><ul><li>grid improvements</li><li>more uniform scrolling across backends</li><li>better scrolling on macos</li><li>web: better support for on screen keyboards</li><li>demo cleanups</li><li>more errors logged to ease development bugs</li><li>ImageSource<ul><li>progress on making <code>image()</code> smarter about when to regenerate textures</li></ul></li><li>Options.data_out<ul><li>general mechanism to extract data about a widget even from a high level api</li></ul></li></ul><p>Big thanks to everyone who landed at least one commit:</p><ul><li>Teodor Källman</li><li>Paul Hatchman</li><li>nat3</li><li>Colton Franklin</li><li>Deins</li><li>Meiko</li></ul><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-07-09">
      <span>July 09, 2025</span>
      <h2><a href="#2025-07-09">Removing Bubbled Events
</a></h2>
      <p>We recently removed callbacks for key events.  This is pushing the immediate-mode paradigm forward in an unexpected way.</p><p>For background, widget relationships can affect who handles each event.  With immediate-mode, a parent widget does not know what children it will see each frame.</p><p>Mouse events:</p><ul><li>parent might process it <strong>before</strong> children<ul><li>example: floating window reserves the bottom-left corner for resizing</li></ul></li><li>parent might process it <strong>after</strong> children<ul><li>example: floating window header does click drag if click is <strong>not</strong> on the close button</li></ul></li></ul><p>This works by checking the event against widget rectangles.  A parent can know if a child got a chance, because all the children are inside the parent’s rectangle.</p><p>Key events are different, they target the widget with keyboard focus.</p><p>Key events:</p><ul><li>parents might process it <strong>after</strong> children<ul><li>example: up arrow on a button should scroll the containing scroll area (if any)</li></ul></li></ul><p>To make this work, we used to have each widget propagate non-processed key events up the parent chain, just in case a parent wanted to process them.</p><p>This works, but uses callbacks.  To add a keyboard shortcut to only a section of the gui, you had to write a whole Widget that was the parent of that whole section.  Ugh.</p><p>We finally found the key question:</p><ul><li>How can a parent know if one of the children had focus?</li></ul><p>More generally:</p><ul><li>How can we know if any sequence of widgets had focus?</li></ul><p>The answer is <code>dvui.lastFocusedIdInFrame()</code>.  It returns the last widget id we saw during this frame that had focus (might be none).</p><p>If you call that twice, and the return is different, then a widget that ran between the two calls had focus.  And you have the id to match events against.</p><p>Now to add a keyboard shortcut to a gui section:</p><ul><li>put the two calls around the section</li><li>if different, match events against the second return</li></ul><p>This is also now what widgets use internally to process key events after children.  It also improves code-flow understanding by not having parent code called during a child’s lifetime.</p>
    </div>
  
    <div id="2025-07-02">
      <span>July 02, 2025</span>
      <h2><a href="#2025-07-02">June 2025
</a></h2>
      <p><strong>8</strong> people contributed this month with <strong>301</strong> commits.</p><p><strong>Colton Franklin</strong> contributed a whole tree widget!</p><ul><li>easily show a filesystem or other tree-like data</li><li>expanding subtrees</li><li>drag-n-drop</li><li>see the “Reorder / Tree” section of the demo</li></ul><p><strong>Teodor Källman</strong> continued their impressive contributions:</p><ul><li>removing errors on most functions (see <a href="#2025-06-17">below</a>)<ul><li>error logs with stack traces</li></ul></li><li>major overhaul of dvui’s allocations:<ul><li>shrinking arena wrapper on Zig’s arena allocator</li><li>splitting dvui’s allocations to improve peak memory use</li></ul></li><li>matching the system light/dark theme by default</li><li>tons of backend fixes and enhancements</li><li>fixes to prevent using undefined</li><li>removing bubbling events (see <a href="#2025-07-09">above</a>)</li></ul><p><strong>Paul Hatchman</strong> put a lot of work into:</p><ul><li>grid features<ul><li>populate the grid by row or col</li><li>resizable columns</li><li>sortable columns</li><li>keyboard navigation</li></ul></li><li>safety checks to prevent use-after-free bugs</li></ul><p><strong>nat3</strong> was back:</p><ul><li>image() from rgba bytes</li><li>rendering tvg at runtime</li></ul><p><strong>Meiko</strong> contributed:</p><ul><li>build.zig changes to improve zls info for backends</li></ul><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-06-24">
      <span>June 24, 2025</span>
      <h2><a href="#2025-06-24">Live Resize on Windows and Mac
</a></h2>
      <p>We all want our applications to repaint smoothly while the OS window is being resized.</p><p>Unfortunately Windows and Mac make this difficult.  The normal event loop is suspended during the entire resize.</p><p>This meant during the resize you saw:</p><ul><li>Windows: frozen last frame maybe cropped or with additional space</li><li>Mac: frozen last frame stretched/squashed to fit</li></ul><p>The underlying problem on both platforms is that they run a nested event loop during the resize, so we lose control.</p><p>There seem to be 2 solutions:</p><ul><li>implement callbacks - render a new frame in the callback</li><li>use multiple threads - render in a separate thread and coordinate</li></ul><p>We now use the callback solution by default in the <strong>SDL3 backend if you are using dvui.App</strong> (so already using callbacks).</p><p>This works, you can see the content reflow while resizing!</p><p>But it is not perfect:</p><ul><li>Windows: <del>it causes a delay when dragging the OS window around by the window title bar</del><ul><li>SDL resolved this issue - we think by disabling vsync during the drag</li></ul></li><li>Mac: resizing introduces some jitter in the sizing of the OS window</li><li>While enabled by default, it can be disabled by <code>-Dsdl3-callbacks=false</code>.</li></ul><p>As best I can tell, to improve on this you have to use multiple threads and put a lot of bespoke code in.</p>
    </div>
  
    <div id="2025-06-17">
      <span>June 17, 2025</span>
      <h2><a href="#2025-06-17">Removing Errors From Most Functions
</a></h2>
      <p>Teodor Källman has successfully removed errors from almost all dvui functions.  Horay!</p><p>Now dvui handles most errors internally:</p><ul><li>If the high level API failes to allocate space for a widget, we panic.<ul><li>The alternative is to allocate the widget on the stack, but it is unclear how that would be better.</li></ul></li><li>If a widget gets an error while rendering, it logs it and continues.</li><li>If a widget gets an allocation error internally (like a label format that goes bad), it logs it and continues.</li></ul><p>Some functions like <code>textureCreate()</code> can still fail.</p><p>Up to this point we hadn’t spent much time thinking about errors.  Everybody (that I saw) put <code>try</code> in front of all dvui functions, and any error took down the whole app.</p><p>Now dvui is aiming to be more robust to errors, especially cases under end-user control.</p><p>For example, if your gui shows user-controlled text or graphs user data, then we’d like for dvui to not crash if the user tries to show way too much text/info.  Ideally dvui continues running and shows some visual indication that something is wrong, allowing the user to get back out of the situation.</p><p>This is the first big push in that direction, and we’ll continue to refine how we handle errors going forward.</p><p>If you have an application where dvui error handling is causing problems, I want to know!  Please file an issue.</p>
    </div>
  
    <div id="2025-06-04">
      <span>June 04, 2025</span>
      <h2><a href="#2025-06-04">Raylib Variable Framerate
</a></h2>
      <p>@sooriya on discord recently asked if we could do variable framerate on raylib, and now we can!</p><p>For waiting on an event without any timeout, raylib already had the necessary pieces with EnableEventWaiting().</p><p>For waiting with a timeout, I submitted a proposal PR to raylib, but it was turned down.  So for that we are assuming that raylib is using glfw and we are directly calling glfwWaitEventsTimeout().</p><p>You can get this either by using dvui.App or copying the relevant parts from the updated examples/raylib-standalone.zig.</p><p>It’s not perfect:</p><ul><li>glfwWaitEventsTimeout() doesn’t tell us if it was interrupted or not</li><li>if an event comes between EndDrawing() and glfwWaitEventsTimeout() we will wait anyway</li></ul><p>But it’s good enough for applications that don’t want to peg the cpu.</p>
    </div>
  
    <div id="2025-06-01">
      <span>June 01, 2025</span>
      <h2><a href="#2025-06-01">May 2025
</a></h2>
      <p><strong>7</strong> people contributed this month with <strong>192</strong> commits.</p><p><strong>nat3</strong> rewrote and improved our icon rendering and compatibility:</p><ul><li><a href="https://github.com/nat3Github/zig-lib-svg2tvg" target="_blank">svg2tvg</a> is now dvui’s icon renderer</li><li><a href="https://github.com/nat3Github/zig-lib-icons" target="_blank">icons</a> hosts many icons in tvg format</li></ul><p>Thank you!</p><p><strong>Paul Hatchman</strong> wrote an entire GridWidget:</p><ul><li>see “Grid” part of the demo for all the cool functionality</li></ul><p>Thank you!</p><p><strong>Teodor Källman</strong> was back again:</p><ul><li><a href="#2025-05-12">type safety</a> for Rect/Size/Point</li><li>type safety for pre-multiplied alpha in Color</li><li>color picker</li><li>debug logging handled and unhandled events</li><li>triangles drawing abstraction supporting:<ul><li>gradients</li><li>box shadows</li><li>textures with rounded corners</li></ul></li><li>snapshots independent of rendering</li><li>better documentation image generation</li><li>suggestion/combobox filtering</li></ul><p>See “Styling” part of the demo for the color picker, box shadows, and gradients.</p><p>Thank you!</p><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-05-22">
      <span>May 22, 2025</span>
      <h2><a href="#2025-05-22">In the Wild: Layer Failure
</a></h2>
      <p><img src="/log/2025/fail_layer.gif"></p><p>What’s going on here:</p><ul><li>I touch “cancel”</li><li>Dialog goes away</li><li>My touch <em>also</em> clicks the button underneath “cancel”</li></ul><p>In the end a store assistant came over and knew some other place on the screen you could touch to get rid of the dialog.</p><p>This kind of thing is why DVUI put a lot of work into the interaction between events and subwindows (dvui’s layers).</p>
    </div>
  
    <div id="2025-05-12">
      <span>May 12, 2025</span>
      <h2><a href="#2025-05-12">Taking Units Seriously
</a></h2>
      <p>DVUI’s main geometry struct is a <code>Rect</code> (rectangle with x,y and width/height).  But what are the units?</p><p>We have 3 common units:</p><ul><li>Physical Pixels<ul><li>1-to-1 with screen/output pixels</li><li>dvui events and drawing use this</li></ul></li><li>Natural Pixels<ul><li>approximately 72 per inch</li><li>will be different from Physical on hidpi screens</li><li>modified by content scaling</li><li>dvui floating windows/widgets use this</li><li>OS events generally use this</li></ul></li><li>Logical Pixels<ul><li>local coordinates possibly modified by parent widgets</li><li>ScaleWidget changes this</li><li>normal widgets use this</li></ul></li></ul><p>For example, you might specify a <code>textEntry</code> with a font that is 16px tall and <code>.min_content_size = .{ .w = 100 }</code>.  Those are logical pixels, so they mean something together, but don’t say anything about how large it will be on the screen.</p><p>To convert, widgets call <code>WidgetData.rectScale()</code> (or similar) which calls <code>parent.screenRectScale()</code> to get a <code>RectScale</code>.  That is a physical rect plus a scale, and represents a rectangle of screen pixels and the scale factor between logical and physical pixels.</p><p>From the beginning we’ve had a steady stream of units errors because the units were implicit.</p><h4>Making Units Explicit</h4><p>We’re trying out adding units to the types.  Now we have:</p><ul><li>Rect (Logical)</li><li>Rect.Physical</li><li>Rect.Natural</li></ul><p>For example <code>RectScale.rectToPhysical()</code> converts from a (logical) Rect to Rect.Physical.  <code>Rect.scale()</code> now requires a unit type representing the units being converted to.</p><p>The drawing functions all take Rect.Physical, and the floating functions take Rect.Natural, hopefully making most units errors into compile errors.</p><p>This has already caught a few bugs, and I’m hoping it helps going forward.</p>
    </div>
  
    <div id="2025-05-01">
      <span>May 01, 2025</span>
      <h2><a href="#2025-05-01">April 2025
</a></h2>
      <p>Special thank you this month to Teodor Källman, who implemented:</p><ul><li>Testing<ul><li>we can now run gui tests as normal zig tests</li><li>testing backend that runs headless</li><li>github actions to run the builtin tests</li><li>snapshot images for ensuring no visible changes</li><li>documentation images produced from tests</li></ul></li><li>Scripting<ul><li>gui interactions can be automated for testing/scripting</li></ul></li><li>Dx11 backend render targets</li><li>Animation easing functions</li><li>Rounded corners on textures</li><li>App<ul><li>higher-level interface for using dvui</li><li>dvui runs the mainloop (you provide a few callbacks)</li><li>app can be run on multiple backends</li></ul></li></ul><p>Thank you to @Yinameah for making the docs look much better!</p><p>7 people contributed this month with 227 commits.</p><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-04-30">
      <span>April 30, 2025</span>
      <h2><a href="#2025-04-30">type-based intent
</a></h2>
      <p>We recently split <code>Texture</code> into two types: <code>Texture</code> and <code>TextureTarget</code>.</p><p>Both have the same fields (pointer, width, height), so what gives?</p><p>Backends make two varieties of textures:  “Normal” ones that are drawn <strong>from</strong>, and “Target” ones that are drawn <strong>to</strong>.</p><p>Some backends (web, raylib) treat these interchangeably.  But sdl can’t read from a “Normal”, and dx11 can’t draw from a “Target”.</p><p>Generally the type you get from the backend is the same, but there is a bit of state associated with it.  We could have done the same:</p><pre><code>pub const Texture = struct {
    is_target: bool,
</code></pre><p>But then we have to check that field (easy to mess up), and have a way to notify developers if they used the wrong kind in the wrong place.</p><h4>Type-based Intent</h4><p>We are now putting that bit of state into the type:</p><pre><code>// this is always &quot;normal&quot;
pub const Texture = struct { ... };

// this is always &quot;target&quot;
pub const TextureTarget = struct { ... };
</code></pre><p>Now you get a compile error when trying to use the wrong one in the wrong place.  Great!</p>
    </div>
  
    <div id="2025-04-01">
      <span>April 01, 2025</span>
      <h2><a href="#2025-04-01">March 2025
</a></h2>
      <p>dvui got a bunch of new stuff this month:</p><ul><li>combobox (combines textEntry and dropdown)</li><li>suggestions (choices that show dynamically under a textEntry)</li><li>tooltips</li><li>web file upload</li><li>simple plots</li><li>kerning</li><li>horizontal mouse wheel support</li></ul><p>Plus a whole ton of minor fixes and enhancements.</p><p>We had 6 people contribute this month!</p><p>Thank you to everyone who asked questions, filed issues, and contributed!</p>
    </div>
  
    <div id="2025-03-11">
      <span>March 11, 2025</span>
      <h2><a href="#2025-03-11">double click, long tap, and friction
</a></h2>
      <p>dvui does not currently have built-in support for double-click, double-tap, or long-tap.  My current thinking is that those interaction patterns are generally worse than the alternatives.</p><p>The general advantage of these is to have a second way to interact with a widget besides a normal click/tap.  Otherwise you need a separate widget, or the widget be modal, or change depending on zoom level, or some other redesign.</p><p>The downsides are poor discoverability and accessibility.  I’ve personally had the experience of trying to double-click or long-tap something, nothing happens, and I’m left unsure if it doesn’t exist or if I did the interaction wrong.</p><p>I’ve watched people with slight hand shakiness try to long-tap repeatedly but only ever get a touch-drag.</p><p>This is why dvui’s textLayout and textEntry widgets provide a modal touch interface.  A single tap transitions between normal mode and selection mode.</p><p>They do have mouse-only 2-click word select and 3-click line select.  Those are features that are useful to some while not requiring use by all.</p><h4>How much should my opinions shape dvui’s design?</h4><p>On one hand dvui must serve its users (developers) in providing the UI features they need and want.</p><p>On the other hand dvui should serve its users by making it easier to build good UIs than bad ones.  Nobody wants a button that by default only responds to a triple-click.</p><p>My strategy is to make requested features possible, but use my experience to guide developers by making some features easier to use than others.</p><p>We see a similar strategy in Zig design, where the core team uses “friction” to guide developers - some patterns are intentionally left more awkward to use than others to discorage their use while not preventing it outright.</p>
    </div>
  
    <div id="2025-02-23">
      <span>February 23, 2025</span>
      <h2><a href="#2025-02-23">min_size_content is not the minimum
</a></h2>
      <p>If the parent does not have enough space, child widgets get less than their min size.</p><p>What about <strong>max_size_content</strong> - can a widget get more?</p><p>Yes - if that widget is expanded, it can be larger than max_size_content.</p><p><strong>min_size_content</strong> and <strong>max_size_content</strong> are both constraints imposed on the minimum size that dvui saves for each widget from frame to frame.</p>
    </div>
  
    <div id="2025-02-22">
      <span>February 22, 2025</span>
      <h2><a href="#2025-02-22">Why min_size_content?
</a></h2>
      <p>To make it clear that padding/border/margin is added on top of that.</p><p>Why not just <strong>min_size</strong>?</p><p>This is an example of naming tension in API design.</p><p>When you want a widget to be larger than its minimum size (but not expanded):</p><pre><code>.{ .min_size_content = .{ .w = 100, .h = 50 } }
</code></pre><p>We could make it shorter and easier to remember by using just <strong>min_size</strong>, but then you have to remember (or lookup) if that already includes padding/border/margin.</p><p>So <strong>min_size_content</strong> costs more characters but makes reading the code (especially for people new to DVUI) slightly easier.</p><p>Hard to know which way to go, but I think about stuff like this a lot.</p>
    </div>
  </div>

    <footer>
      <hr>
    </footer>
  </body>
</html>
